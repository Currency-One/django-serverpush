from collections import deque
from bisect import bisect_left
import urllib
import time

from django.core.urlresolvers import resolve
from django.contrib.sessions.backends.db import SessionStore
from django.contrib.auth.models import User
from django.contrib.auth.models import AnonymousUser

class EventTracker():
	def __init__(self):
		self.channels = {}

	def connect(self, conn):
		#auth
		session = SessionStore(session_key = conn.cookie_id)
		if '_auth_user_id' in session:
			user = User.objects.get(id = session['_auth_user_id'])
		else:
			user = AnonymousUser()
			
		filters = []
		
		#url resolve
		func, args, kwargs = resolve(conn.url)
		
		#get _update function
		try:
			func = getattr(__import__(func.__module__, globals(), locals(), [func.__name__ + '_update']), func.__name__ + '_update')
		except:
			func = None
			
		if func: #if function _update is defined
			filters += func(user, session, conn.GET, *args, **kwargs)
		
		for filter in filters:
			#resolve model to string
			model = filter['model'].__module__ + '.' + filter['model'].__name__
			#create a new channel for this model
			if model not in self.channels: self.channels[model] = Channel()
			#add filter to the channel
			self.channels[model].newFilter(conn, filter)

	def disconnect(self, conn):
		for channel in self.channels:
			if conn.id in self.channels[channel].connections: del self.channels[channel].connections[conn.id]

	def event(self, model, id):	
		#resolve model to object
		try:
			object = getattr(__import__(model.rsplit('.', 1)[0], globals(), locals(), [model.split('.')[-1]]), model.split('.')[-1]).objects.filter(pk = id)
		except:
			return False
		
		if not object.exists():
			return False
		
		if model not in self.channels:
			self.channels[model] = Channel()
		
		return self.channels[model].event(object)

class Channel():
	def __init__(self):
		self.maxsize = 200
		self.history = deque(maxlen = self.maxsize)
		self.connections = {}

	def newFilter(self, conn, filter):
		if conn.id not in self.connections: self.connections[conn.id] = []
		filter = {'name':filter['name'], 'params':filter['params'], 'serializer':filter.get('serializer', extract), 'data':filter['data'], 'conn':conn}
		self.connections[conn.id].append(filter)
		self.sendHistory(filter)

	def event(self, object):
		self.history.append((time.time(), object))
		
		buffer = SendBuffer()
		for conn in self.connections:
			for filter in self.connections[conn]:
				if object.filter(**filter['params']).exists():
					buffer.append(filter['conn'], {'name':filter['name'], 'payload':filter['serializer'](object[0], filter['data'])})
		buffer.send()
		
		return True

	def sendHistory(self, filter):
		if len(self.history) == self.maxsize and self.history[0]['timestamp'] > filter['conn'].timestamp:
			filter['conn'].send_frame('EVENT', {'name':'refresh'}) #history has failed us
			return
		
		buffer = SendBuffer()
		start = bisect_left(self.history, (filter['conn'].timestamp, None))
		for i in range(start, len(self.history)):
			object = self.history[i][1]
			if object.filter(**filter['params']).exists():
				buffer.append(filter['conn'], {'name':filter['name'], 'payload':filter['serializer'](object[0], filter['data'])})
		buffer.send()

class SendBuffer():
	def __init__(self):
		self.buffer = []

	def append(self, conn, data):
		self.buffer.append([conn, data])

	def send(self):
		for package in self.buffer:
			package[0].send_frame('EVENT', package[1])

def extract(object, fields):
	data = {}
	for field in fields:
		data[field] = eval(fields[field])
	return data

def ping_notifier(model, pk = None):
	if not pk:
		pk = model.pk
		model = model.__class__

	try:
		urllib.urlopen('http://localhost:8014/%s/%s' % (model.__module__ + '.' + model.__name__, pk))
		return True
	except IOError:
		return False

def context_processor(request):
	return {'generated_timestamp':str(time.time())} #TODO: it should be calculated at the beggining of the request

